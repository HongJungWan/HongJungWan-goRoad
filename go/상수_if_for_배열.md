## Tucker의 Go 언어 프로그래밍 - 요약

<br>

### #3 상수, if, for, 배열

<br><br>

### 상수 선언

상수는 변하지 않는 값을 말한다. 변수는 대입문을 통해서 값을 수시로 바꿀 수 있지만 상수는 초기화된 값이 변하지 않는다.

<br>

상수로 사용될 수 있는 타입은 다음과 같다.

* 불리언
* 룬(rune)
* 정수
* 실수
* 복소수
* 문자열

<br>

상수 선언 방식은 변수와 비슷하다. 변수(variable)를 뜻하는 var 대신 상수(constant)를 뜻하는 const 키워드를 사용한다는 점이 다르다.

<br>

```go
const ConstValue int = 10
```

* 상수명 규칙은 변수 명과 같다.

* 함수 외부에 선언되어 있고 첫 글자가 대문자인 상수는 패키지 외부로 공개되는 상수다.

* 상수는 한 번 선언되면 그 값을 바꿀 수 없다.

<br>

```go
package main

import "fmt"

func main() {
    const C int = 10
    var b int C * 20

    C = 20
    fmt.Println(&C)
}
```

<br><br>

### 상수는 언제나 사용하는가?

상수는 보통 변하면 안 되는 값에 사용하고, 코드를 통해 숫자에 의미를 부여할 때 사용한다.

<br><br>

### iota로 간편하게 열거 값 사용하기

```go
const (
    RED int = iota   // 0
    BLUE int = iota  // 1
    Green int = iota // 2
)
```

1,2,3..처럼 1씩 증가하도록 정의할 때 iota 키워드를 사용하면 편리하다.

<br><br>

### 타입 없는 상수

상수 선언 시 타입을 명시하지 않을 수 있다. 그러면 타입 없는 상수가 된다.

타입 없는 상수는 변수에 복사될 때 타입이 정해지기 때문에 여러 타입에 사용되는 상수 값을 사용할 때 편리하다.

<br><br>

### 상수와 리터럴

컴퓨터에서 `리터럴이란 고정된 값`, 값 자체로 쓰인 문구라고 볼 수 있다.

```go
var str stirng = "Hello World"
var i int = 0
i = 30
```

위 코드에서 "Hello World", 0 , 30과 같이 고정된 값 자체로 쓰인 문구가 바로 리터럴이다. 

Go 언어에서 상수는 리털럴과 같이 취급한다. 그래서 컴파일 될 때 상수는 리터럴로 변환되어 실행 파일에 쓰인다.

<br>

상수 표현식 역시 컴파일 타임에 실제 결과값 리터럴로 변환하기 때문에 상수 표현식 계산에 CPU 자원을 사용하지 않는다.

```go
const PI = 3.14
var a int = PI * 100
```

<br>

위 구문은 컴파일 타임에 아래와 같이 변한다.

```go
var a int = 314
```

상수의 메모리 주소값에 접근할 수 없는 이유 역시 컴파일 타임에 리터럴로 전환되어서 실행 파일에 값 형태로 쓰이기 때문이다. 

그래서 동적 할당 메모리 영역을 사용하지 않는다.

<br><br>

### if 문 

if 문은 조건에 따라 분기하는 구문이다.

```go
if 조건문 {
    문장
} else if 조건문 {
    문장
} else {
    문장
}
```

<br><br>

### 쇼트 서킷 (short-circuit)

&& 연산은 좌변이 false 이면 우변을 검사하지 않고 false 처리를 한다. 

|| 연산 역시 좌변이 true 이면 우변은 검사하지 않고 true 처리를 한다. 이것을 쇼트 서킷(short-circuit)라고 한다.

조건문은 우변이 실행되지 않을 수 있으므로 이를 염두에 두고 구현해야 한다.

<br><br>

### for 문

반복 작업을 할 때 for 문을 지원한다. 

Go에서는 반복문을 for 문 하나만 지원한다.

```go
for 초기문 ; 조건문; 후처리 {
    코드블록
}
```

<br><br>

### 배열

배열(array)은 같은 타입의 데이터들로 이루어진 타입이다. 

배열을 이루는 각 값은 요소라고 하고 요소(element)를 가리키는 위치 값을 인덱스(index)라고 한다.

```go
var 변수명 [요소 개수] 타입
```

<br><br>

### 배열 선언 및 초기화

```go
var nums [5] int
```
int 타입 요소를 5 개 갖는 배열 nums를 할당한다. 

별도로 초깃값을 지정하지 않아 각 요솟값을 int 타입의 기본값인 0으로 초기화한다.

<br>

```go
days := [3]string{"monday","tusday","wednesday"}
```

string 타입 요소를 3개 갖는 배열 days를 할당한다.

<br><br>

```go
x:=[...]int{10,20,30}
```

...를 사용해 배열 요소 개수를 생략할 수 있다. 

이때 배열 요소 개수는 초기화되는 요소 개수와 같다.

<br><br>

### range 순회

for 반복문에서 range 키워드를 이용하면 배열 요소를 순회할 수 있다.

```go
package main

import "fmt"

func main() {
    var t [5]float64 = [5]float64{24.0, 25.9, 27.8, 26.9, 26.2}
    
    for i, v := range t {
        fmt.Println(i, v)
    }
}
```

range는 배열의 각 요소를 순회하면서 인덱스와 요솟값 두값을 반환한다. 

위 코드는 선언 대입문을 사용하여 i 변수에는 인덱스 값을 대입하고 v 변수에는 요솟값을 대입.

<br><br>

### 배열은 연속된 메모리

배열은 선언하면 컴퓨터는 연속된 메모리 공간을 확보한다. 

예를 들어 a 배열 시작 주소가 100번지라면 `a[3]의 주소`는 int32 타입 크기는 4 바이트 이므로 100 + (3*4) = 112번지가 된다.

배열은 연속된 메모리고 컴퓨터는 인덱스와 타입 크기를 사용해서 메모리 주소를 찾는다.

<br><br>

### 배열 복사

대입 연산자를 사용하면 배열 대 배열 복사를 할 수 있다.

```go
    a := [...]int{1, 2, 3, 4, 5}
    b := [...]int{100, 200, 300, 400, 500}
        
    a = b
```

위 코드는 우변의 값을 좌변의 메모리 공간에 복사하며, 대입 시 각 항의 타입은 항상 같아야 한다.

<br><br>